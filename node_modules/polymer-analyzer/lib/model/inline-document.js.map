{"version":3,"sources":["model/inline-document.ts"],"names":[],"mappings":"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","file":"inline-document.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as dom5 from 'dom5';\nimport * as parse5 from 'parse5';\nimport {ASTNode} from 'parse5';\nimport * as util from 'util';\n\nimport {isFakeNode} from '../html/html-document';\nimport * as jsdoc from '../javascript/jsdoc';\n\nimport {Document, ScannedDocument} from './document';\nimport {ScannedFeature} from './feature';\nimport {unsafeAsMutable} from './immutable';\nimport {Resolvable} from './resolvable';\nimport {LocationOffset, SourceRange} from './source-range';\nimport {Warning} from './warning';\n\nexport interface InlineDocInfo<AstNode> {\n  astNode?: AstNode;\n  locationOffset?: LocationOffset;\n}\n\n/**\n * Represents an inline document, usually a <script> or <style> tag in an HTML\n * document.\n *\n * @template N The AST node type\n */\nexport class ScannedInlineDocument implements ScannedFeature, Resolvable {\n  type: 'html'|'javascript'|'css'|/* etc */ string;\n\n  contents: string;\n\n  /** The location offset of this document within the containing document. */\n  locationOffset: LocationOffset;\n  attachedComment?: string;\n\n  scannedDocument?: ScannedDocument;\n\n  sourceRange: SourceRange;\n  warnings: Warning[] = [];\n\n  astNode: dom5.Node;\n\n  constructor(\n      type: string, contents: string, locationOffset: LocationOffset,\n      attachedComment: string, sourceRange: SourceRange, ast: dom5.Node) {\n    this.type = type;\n    this.contents = contents;\n    this.locationOffset = locationOffset;\n    this.attachedComment = attachedComment;\n    this.sourceRange = sourceRange;\n    this.astNode = ast;\n  }\n\n  resolve(document: Document): Document|undefined {\n    if (!this.scannedDocument) {\n      // Parse error on the inline document.\n      return;\n    }\n    const inlineDocument = new InlineDocument(this.scannedDocument, document);\n    inlineDocument.resolve();\n    return inlineDocument;\n  }\n}\n\ndeclare module './queryable' {\n  interface FeatureKindMap {\n    'inline-document': InlineDocument;\n  }\n}\nexport class InlineDocument extends Document {\n  constructor(base: ScannedDocument, containerDocument: Document) {\n    super(base, containerDocument._analysisContext);\n    unsafeAsMutable(this.kinds).add('inline-document');\n    this._addFeature(containerDocument);\n  }\n}\n\nexport function getAttachedCommentText(node: ASTNode): string|undefined {\n  const commentNode = getAttachedCommentNode(node);\n  if (!commentNode) {\n    return;\n  }\n  const comment = dom5.getTextContent(commentNode);\n  if (!comment || /@license/.test(comment)) {\n    return;\n  }\n  return jsdoc.unindent(comment).trim();\n}\n\nfunction getAttachedCommentNode(node: ASTNode): ASTNode|undefined {\n  const predecessors = getPreviousSiblings(node);\n  const visiblePredecessors = filterOutInvisibleNodes(predecessors);\n  const [closestVisiblePredecessor] = visiblePredecessors;\n  if (!closestVisiblePredecessor) {\n    return;  // no predecessors at all\n  }\n  if (!dom5.isCommentNode(closestVisiblePredecessor)) {\n    return;  // attached node isn't a comment\n  }\n  return closestVisiblePredecessor;\n}\n\n/**\n * Filter out nodes that are just whitespace, or aren't present in the original\n * source text of the file.\n */\nfunction*\n    filterOutInvisibleNodes(nodeIter: Iterable<ASTNode>): Iterable<ASTNode> {\n  for (const node of nodeIter) {\n    // Ignore nodes that aren't present in the original text of the file,\n    // like parser-hallucinated <head> and <body> nodes.\n    if (isFakeNode(node)) {\n      continue;\n    }\n    // Ignore text nodes that are just whitespace\n    if (dom5.isTextNode(node)) {\n      const text = dom5.getTextContent(node).trim();\n      if (text === '') {\n        continue;\n      }\n    }\n    yield node;\n  }\n}\n\n/**\n * An iterable over siblings that come before the given node.\n *\n * Note that this method gives siblings from the author's point of view, not\n * the pedantic parser's point of view, so we need to traverse some fake\n * nodes. e.g. consider this document\n *\n *     <link rel=\"import\" href=\"foo.html\">\n *     <dom-module></dom-module>\n *\n * For this method's purposes, these nodes are siblings, but in the AST\n * they're actually cousins! The link is in a hallucinated <head> node, and\n * the dom-module is in a hallucinated <body> node, so to get to the link we\n * need to go up to the body, then back to the head, then back down, but\n * only if the head and body are hallucinated.\n */\nfunction* getPreviousSiblings(node: ASTNode): Iterable<ASTNode> {\n  const parent = node.parentNode;\n  if (parent) {\n    const siblings = parent.childNodes!;\n    for (let i = siblings.indexOf(node) - 1; i >= 0; i--) {\n      const predecessor = siblings[i];\n      if (isFakeNode(predecessor)) {\n        if (predecessor.childNodes) {\n          yield* iterReverse(predecessor.childNodes);\n        }\n      } else {\n        yield predecessor;\n      }\n    }\n    if (isFakeNode(parent)) {\n      yield* getPreviousSiblings(parent);\n    }\n  }\n}\n\nfunction* iterReverse<V>(arr: Array<V>): Iterable<V> {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isLocationInfo(loc: (parse5.LocationInfo|parse5.ElementLocationInfo)):\n    loc is parse5.LocationInfo {\n  return 'line' in loc;\n}\n\nexport function getLocationOffsetOfStartOfTextContent(node: ASTNode):\n    LocationOffset {\n  const childNodes = node.childNodes || [];\n  const firstChildNodeWithLocation = childNodes.find((n) => !!n.__location);\n  const bestLocation = firstChildNodeWithLocation ?\n      firstChildNodeWithLocation.__location :\n      node.__location;\n  if (!bestLocation) {\n    throw new Error(\n        `Couldn't extract a location offset from HTML node: ` +\n        `${util.inspect(node)}`);\n  }\n  if (isLocationInfo(bestLocation)) {\n    return {line: bestLocation.line - 1, col: bestLocation.col - 1};\n  } else {\n    return {\n      line: bestLocation.startTag.line - 1,\n      col: bestLocation.startTag.endOffset - 1,\n    };\n  }\n}\n"]}