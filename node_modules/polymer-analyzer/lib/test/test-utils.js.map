{"version":3,"sources":["test/test-utils.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;AAEH,+CAA0C;AAC1C,oCAAkD;AAElD,iEAAsE;AAEtE,0DAAsD;AAGtD,+BAAuC,SAAQ,KAAK;IAElD,YAAY,OAAe,EAAE,aAAkB;QAC7C,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;IACrC,CAAC;CACF;AAND,8DAMC;AAED,uBAAoC,OAAqB;;QACvD,IAAI,KAAU,CAAC;QACf,IAAI,CAAC;YACH,KAAK,GAAG,MAAM,OAAO,CAAC;QACxB,CAAC;QAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACX,MAAM,CAAC,CAAC,CAAC;QACX,CAAC;QACD,MAAM,IAAI,yBAAyB,CAAC,2BAA2B,EAAE,KAAK,CAAC,CAAC;IAC1E,CAAC;CAAA;AARD,sCAQC;AAID;;;;;GAKG;AACH;IAEE,YAAY,SAAoB;QAC9B,MAAM,QAAQ,GAAG,IAAI,mBAAQ,CAAC,EAAC,SAAS,EAAC,CAAC,CAAC;QAC3C,IAAI,CAAC,qBAAqB,GAAG,CAAM,GAAW;YAC5C,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC/C,MAAM,MAAM,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YACzC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,YAAY,gBAAQ,CAAC,CAAC,CAAC,CAAC;gBAClC,MAAM,IAAI,KAAK,CAAC,mBAAmB,GAAG,EAAE,CAAC,CAAC;YAC5C,CAAC;YACD,MAAM,CAAC,MAAM,CAAC,cAAc,CAAC;QAC/B,CAAC,CAAA,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,WAAW,CAAC,GAAW,EAAE,QAAgB;QAC9C,MAAM,SAAS,GAAG,IAAI,yCAAwB,EAAE,CAAC;QACjD,SAAS,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QAC5C,MAAM,CAAC,IAAI,cAAc,CAAC,SAAS,CAAC,CAAC;IACvC,CAAC;IAWK,SAAS,CAAC,SAAgC;;YAC9C,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBAC7B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAClE,CAAC;YAED,EAAE,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,CAAC,CAAC;gBAC5B,MAAM,CAAC,wBAAwB,CAAC;YAClC,CAAC;YACD,EAAE,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACzB,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC,QAAQ,CAAC,EAAC,SAAS,EAAE,WAAW,EAAE,KAAK,EAAE,KAAK,EAAC,CAAC,CAAC;YAC3E,CAAC;YACD,8DAA8D;YAC9D,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YACxE,MAAM,CAAC,IAAI,GAAG,4BAAa,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;QACzD,CAAC;KAAA;CACF;AA5CD,wCA4CC;AAED,mBAAmB,IAAyB;IAC1C,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC;AACxB,CAAC","file":"test-utils.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {Analyzer} from '../core/analyzer';\nimport {Document, ParsedDocument} from '../index';\nimport {SourceRange, Warning} from '../model/model';\nimport {InMemoryOverlayUrlLoader} from '../url-loader/overlay-loader';\nimport {UrlLoader} from '../url-loader/url-loader';\nimport {underlineCode} from '../warning/code-printer';\n\n\nexport class UnexpectedResolutionError extends Error {\n  resolvedValue: any;\n  constructor(message: string, resolvedValue: any) {\n    super(message);\n    this.resolvedValue = resolvedValue;\n  }\n}\n\nexport async function invertPromise(promise: Promise<any>): Promise<any> {\n  let value: any;\n  try {\n    value = await promise;\n  } catch (e) {\n    return e;\n  }\n  throw new UnexpectedResolutionError('Inverted Promise resolved', value);\n}\n\nexport type Reference = Warning | SourceRange | undefined;\n\n/**\n * Used for asserting that warnings or source ranges correspond to the right\n * parts of the source code.\n *\n * Non-test code probably wants WarningPrinter instead.\n */\nexport class CodeUnderliner {\n  private _parsedDocumentGetter: (url: string) => Promise<ParsedDocument>;\n  constructor(urlLoader: UrlLoader) {\n    const analyzer = new Analyzer({urlLoader});\n    this._parsedDocumentGetter = async(url: string) => {\n      const analysis = await analyzer.analyze([url]);\n      const result = analysis.getDocument(url);\n      if (!(result instanceof Document)) {\n        throw new Error(`Unable to parse ${url}`);\n      }\n      return result.parsedDocument;\n    };\n  }\n\n  static withMapping(url: string, contents: string) {\n    const urlLoader = new InMemoryOverlayUrlLoader();\n    urlLoader.urlContentsMap.set(url, contents);\n    return new CodeUnderliner(urlLoader);\n  }\n\n  /**\n   * Converts one or more warnings/source ranges into underlined text.\n   *                                                  ~~~~~~~~~~ ~~~~\n   *\n   * This has a loose set of types that it will accept in order to make\n   * writing tests simple and legible.\n   */\n  async underline(reference: Reference): Promise<string>;\n  async underline(references: Reference[]): Promise<string[]>;\n  async underline(reference: Reference|Reference[]): Promise<string|string[]> {\n    if (Array.isArray(reference)) {\n      return Promise.all(reference.map((ref) => this.underline(ref)));\n    }\n\n    if (reference === undefined) {\n      return 'No source range given.';\n    }\n    if (isWarning(reference)) {\n      return '\\n' + reference.toString({verbosity: 'code-only', color: false});\n    }\n    // We have a reference without its parsed document. Go get it.\n    const parsedDocument = await this._parsedDocumentGetter(reference.file);\n    return '\\n' + underlineCode(reference, parsedDocument);\n  }\n}\n\nfunction isWarning(wOrS: Warning|SourceRange): wOrS is Warning {\n  return 'code' in wOrS;\n}\n"]}